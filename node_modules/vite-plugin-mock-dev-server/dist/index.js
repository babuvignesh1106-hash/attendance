import { createLogger, createMatcher, createMockMiddleware, debug, doesProxyContextMatchUrl, isPackageExists, isPathMatch, logLevels, mockWebSocket, normalizePath, processMockData, processRawData, recoverRequest, sortByValidator, urlParse } from "./server-G9rXmGpR.js";
import { createDefineMock, createSSEStream, defineMock, defineMockData } from "./helper-BbR8Si2U.js";
import { isArray, isBoolean, promiseParallel, toArray, uniq } from "@pengzhanbo/utils";
import fs, { promises } from "node:fs";
import fsp from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import ansis from "ansis";
import { getPackageInfoSync, loadPackageJSON, loadPackageJSONSync } from "local-pkg";
import { pathToFileURL } from "node:url";
import JSON5 from "json5";
import EventEmitter from "node:events";
import { watch } from "chokidar";
import { glob } from "tinyglobby";
import isCore from "is-core-module";
import cors from "cors";

//#region src/compiler/esbuild.ts
const externalizeDeps = {
	name: "externalize-deps",
	setup(build) {
		build.onResolve({ filter: /.*/ }, ({ path: id }) => {
			if (id[0] !== "." && !path.isAbsolute(id)) return { external: true };
		});
	}
};
const json5Loader = {
	name: "json5-loader",
	setup(build) {
		build.onLoad({ filter: /\.json5$/ }, async ({ path: path$1 }) => {
			const content = await fsp.readFile(path$1, "utf-8");
			return {
				contents: `export default ${JSON.stringify(JSON5.parse(content))}`,
				loader: "js"
			};
		});
	}
};
const jsonLoader = {
	name: "json-loader",
	setup(build) {
		build.onLoad({ filter: /\.json$/ }, async ({ path: path$1 }) => {
			const content = await fsp.readFile(path$1, "utf-8");
			return {
				contents: `export default ${content}`,
				loader: "js"
			};
		});
	}
};
const renamePlugin$1 = {
	name: "rename-plugin",
	setup(build) {
		build.onResolve({ filter: /.*/ }, ({ path: id }) => {
			if (id === "vite-plugin-mock-dev-server") return {
				path: "vite-plugin-mock-dev-server/helper",
				external: true
			};
			return null;
		});
	}
};
function aliasPlugin(alias) {
	return {
		name: "alias-plugin",
		setup(build) {
			build.onResolve({ filter: /.*/ }, async ({ path: id }) => {
				const matchedEntry = alias.find(({ find: find$1 }) => aliasMatches(find$1, id));
				if (!matchedEntry) return null;
				const { find, replacement } = matchedEntry;
				const result = await build.resolve(id.replace(find, replacement), {
					kind: "import-statement",
					resolveDir: replacement,
					namespace: "file"
				});
				return {
					path: result.path,
					external: false
				};
			});
		}
	};
}
function aliasMatches(pattern, importee) {
	if (pattern instanceof RegExp) return pattern.test(importee);
	if (importee.length < pattern.length) return false;
	if (importee === pattern) return true;
	return importee.startsWith(`${pattern}/`);
}
let _build = null;
async function esbuild() {
	_build ||= (await import("esbuild")).build;
	return _build;
}
async function transformWithEsbuild(entryPoint, { isESM = true, define, alias, cwd = process.cwd() }) {
	const filepath = path.resolve(cwd, entryPoint);
	const filename = path.basename(entryPoint);
	const dirname = path.dirname(filepath);
	try {
		const build = await esbuild();
		const result = await build({
			entryPoints: [entryPoint],
			outfile: "out.js",
			write: false,
			target: ["node18"],
			platform: "node",
			bundle: true,
			metafile: true,
			format: isESM ? "esm" : "cjs",
			define: {
				...define,
				__dirname: JSON.stringify(dirname),
				__filename: JSON.stringify(filename),
				...isESM ? {} : { "import.meta.url": JSON.stringify(pathToFileURL(filepath)) }
			},
			plugins: [
				aliasPlugin(alias),
				renamePlugin$1,
				externalizeDeps,
				jsonLoader,
				json5Loader
			],
			absWorkingDir: cwd
		});
		const deps = /* @__PURE__ */ new Set();
		const inputs = result.metafile?.inputs || {};
		Object.keys(inputs).forEach((key) => inputs[key].imports.forEach((dep) => deps.add(dep.path)));
		return {
			code: result.outputFiles[0].text,
			deps: Array.from(deps)
		};
	} catch (e) {
		console.error(e);
	}
	return {
		code: "",
		deps: []
	};
}

//#endregion
//#region src/compiler/loadFromCode.ts
async function loadFromCode({ filepath, code, isESM, cwd }) {
	filepath = path.resolve(cwd, filepath);
	const ext = isESM ? ".mjs" : ".cjs";
	const filepathTmp = `${filepath}.timestamp-${Date.now()}${ext}`;
	const file = pathToFileURL(filepathTmp).toString();
	await promises.writeFile(filepathTmp, code, "utf8");
	try {
		const mod = await import(file);
		return mod.default || mod;
	} finally {
		try {
			fs.unlinkSync(filepathTmp);
		} catch {}
	}
}

//#endregion
//#region src/compiler/rolldown.ts
const renamePlugin = {
	name: "vite-mock:rename-plugin",
	resolveId(id) {
		if (id === "vite-plugin-mock-dev-server") return {
			id: "vite-plugin-mock-dev-server/helper",
			external: true
		};
	}
};
const json5Plugin = {
	name: "vite-mock:json5-plugin",
	transform: {
		filter: { id: /\.json5$/ },
		handler: (code) => {
			return { code: `export default ${JSON5.stringify(JSON5.parse(code))}` };
		}
	}
};
let _rolldown = null;
async function rolldown() {
	_rolldown ||= {
		build: (await import("rolldown")).build,
		aliasPlugin: (await import("rolldown/experimental")).aliasPlugin
	};
	return _rolldown;
}
async function transformWithRolldown(entryPoint, { isESM = true, define, alias, cwd = process.cwd() }) {
	const filepath = path.resolve(cwd, entryPoint);
	const filename = path.basename(entryPoint);
	const dirname = path.dirname(filepath);
	const isAlias = (p) => !!alias.find(({ find }) => aliasMatches(find, p));
	try {
		const { build, aliasPlugin: aliasPlugin$1 } = await rolldown();
		const result = await build({
			input: entryPoint,
			write: false,
			cwd,
			output: {
				format: isESM ? "esm" : "cjs",
				sourcemap: false,
				file: "out.js"
			},
			platform: "node",
			define: {
				...define,
				__dirname: JSON.stringify(dirname),
				__filename: JSON.stringify(filename),
				...isESM ? {} : { "import.meta.url": JSON.stringify(pathToFileURL(filepath)) }
			},
			external(id) {
				if (isAlias(id)) return false;
				if (id[0] !== "." && !path.isAbsolute(id) && id !== "vite-plugin-mock-dev-server") return true;
			},
			plugins: [
				aliasPlugin$1({ entries: alias }),
				renamePlugin,
				json5Plugin
			]
		});
		return {
			code: result.output[0].code,
			deps: result.output[0].imports
		};
	} catch (e) {
		console.error(e);
	}
	return {
		code: "",
		deps: []
	};
}

//#endregion
//#region src/compiler/compile.ts
async function transform(entryPoint, options) {
	if (await isPackageExists("rolldown")) return transformWithRolldown(entryPoint, options);
	if (await isPackageExists("esbuild")) return transformWithEsbuild(entryPoint, options);
	throw new Error("rolldown or esbuild not found");
}
async function compile(filepath, options) {
	let isESM = false;
	if (/\.m[jt]s$/.test(filepath)) isESM = true;
	else if (/\.c[jt]s$/.test(filepath)) isESM = false;
	else isESM = options.isESM || false;
	const { code, deps } = await transform(filepath, {
		...options,
		isESM
	});
	const data = await loadFromCode({
		filepath,
		code,
		isESM,
		cwd: options.cwd || process.cwd()
	}) || {};
	return {
		data,
		deps
	};
}

//#endregion
//#region src/compiler/compiler.ts
/**
* Mock 文件加载编译，并转换为 Mock 数据
*/
var Compiler = class extends EventEmitter {
	moduleCache = /* @__PURE__ */ new Map();
	moduleDeps = /* @__PURE__ */ new Map();
	cwd;
	mockWatcher;
	depsWatcher;
	isESM = false;
	_mockData = {};
	constructor(options) {
		super();
		this.options = options;
		this.cwd = options.cwd || process.cwd();
		try {
			const pkg = loadPackageJSONSync(this.cwd);
			this.isESM = pkg?.type === "module";
		} catch {}
	}
	get mockData() {
		return this._mockData;
	}
	run(watch$1) {
		const { include, exclude } = this.options;
		const { pattern, ignore, isMatch } = createMatcher(include, exclude);
		glob(pattern, {
			ignore,
			cwd: path.join(this.cwd, this.options.dir)
		}).then((files) => files.map((file) => () => this.load(path.join(this.options.dir, file)))).then((loaders) => promiseParallel(loaders, 64)).then(() => this.updateMockData());
		if (!watch$1) return;
		this.watchMockEntry(isMatch);
		this.watchDeps();
		let timer = null;
		this.on("mock:update", async (filepath) => {
			if (!isMatch(filepath)) return;
			await this.load(filepath);
			if (timer) clearImmediate(timer);
			timer = setImmediate(() => {
				this.updateMockData();
				this.emit("mock:update-end", normalizePath(filepath));
				timer = null;
			});
		});
		this.on("mock:unlink", async (filepath) => {
			if (!isMatch(filepath)) return;
			filepath = normalizePath(path.join(this.options.dir, filepath));
			this.moduleCache.delete(filepath);
			this.updateMockData();
			this.emit("mock:update-end", filepath);
		});
	}
	close() {
		this.mockWatcher?.close();
		this.depsWatcher?.close();
	}
	async load(filepath) {
		if (!filepath) return;
		try {
			const { define, alias } = this.options;
			const { data, deps } = await compile(filepath, {
				cwd: this.cwd,
				isESM: this.isESM,
				define,
				alias
			});
			this.moduleCache.set(filepath, processRawData(data, filepath));
			this.updateModuleDeps(filepath, deps);
		} catch (e) {
			console.error(e);
		}
	}
	updateMockData() {
		this._mockData = processMockData(this.moduleCache);
	}
	updateModuleDeps(filepath, deps) {
		for (const dep of deps) {
			if (!this.moduleDeps.has(dep)) this.moduleDeps.set(dep, /* @__PURE__ */ new Set());
			const cur = this.moduleDeps.get(dep);
			cur.add(filepath);
		}
		this.emit("update:deps");
	}
	watchMockEntry(isMatch) {
		const watcher = this.mockWatcher = watch(this.options.dir, {
			ignoreInitial: true,
			cwd: this.cwd,
			ignored: (filepath, stats) => {
				if (filepath.includes("node_modules")) return true;
				return !!stats?.isFile() && !isMatch(filepath);
			}
		});
		watcher.on("add", async (filepath) => {
			filepath = normalizePath(filepath);
			this.emit("mock:update", filepath);
			debug("watcher:add", filepath);
		});
		watcher.on("change", async (filepath) => {
			filepath = normalizePath(filepath);
			this.emit("mock:update", filepath);
			debug("watcher:change", filepath);
		});
		watcher.on("unlink", async (filepath) => {
			filepath = normalizePath(filepath);
			this.emit("mock:unlink", filepath);
			debug("watcher:unlink", filepath);
		});
	}
	watchDeps() {
		let oldDeps = [...this.moduleDeps.keys()];
		const watcher = this.depsWatcher = watch([...oldDeps], {
			ignoreInitial: true,
			cwd: this.cwd
		});
		watcher.on("change", (filepath) => {
			filepath = normalizePath(filepath);
			const mockFiles = this.moduleDeps.get(filepath);
			mockFiles?.forEach((file) => this.emit("mock:update", file));
		});
		watcher.on("unlink", (filepath) => {
			filepath = normalizePath(filepath);
			this.moduleDeps.delete(filepath);
		});
		this.on("update:deps", () => {
			const deps = [...this.moduleDeps.keys()];
			const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
			oldDeps = deps;
			if (exactDeps.length > 0) watcher.add(exactDeps);
		});
	}
};

//#endregion
//#region src/build/mockEntryCode.ts
async function generateMockEntryCode(cwd, dir, include, exclude) {
	const { pattern, ignore } = createMatcher(include, exclude);
	const mockFiles = await glob(pattern, {
		ignore,
		cwd: path.join(cwd, dir)
	});
	let importers = "";
	const exporters = [];
	mockFiles.forEach((filepath, index) => {
		const file = normalizePath(path.join(cwd, dir, filepath));
		importers += `import * as m${index} from '${file}';\n`;
		exporters.push(`[m${index}, '${normalizePath(path.join(dir, filepath))}']`);
	});
	return `import { processMockData, processRawData } from 'vite-plugin-mock-dev-server/server';
${importers}
const exporters = [\n  ${exporters.join(",\n  ")}\n];
const mockList = exporters.map(([mod, filepath]) => processRawData(mod.default || mod, filepath));
export default processMockData(mockList);`;
}

//#endregion
//#region package.json
var name = "vite-plugin-mock-dev-server";
var version = "2.0.1";

//#endregion
//#region src/build/packageJson.ts
/**
* 从 mock 文件的 importers 中获取依赖
*/
function getMockDependencies(deps, alias) {
	const list = /* @__PURE__ */ new Set();
	const excludeDeps = [
		name,
		"connect",
		"cors"
	];
	const isAlias = (p) => alias.find(({ find }) => aliasMatches(find, p));
	deps.forEach((dep) => {
		const name$1 = normalizePackageName(dep);
		if (name$1.startsWith("<define:") || isAlias(name$1) || isCore(name$1)) return;
		if (name$1[0] === "/" || name$1.startsWith("./") || name$1.startsWith("../")) return;
		if (!excludeDeps.includes(name$1)) list.add(name$1);
	});
	return Array.from(list);
}
function normalizePackageName(dep) {
	const [scope, name$1] = dep.split("/");
	if (scope[0] === "@") return `${scope}/${name$1}`;
	return scope;
}
function generatePackageJson(pkg, mockDeps) {
	const { dependencies = {}, devDependencies = {} } = pkg;
	const dependents = {
		...dependencies,
		...devDependencies
	};
	const mockPkg = {
		name: "mock-server",
		type: "module",
		scripts: { start: "node index.js" },
		dependencies: {
			connect: "^3.7.0",
			[name]: `^${version}`,
			cors: "^2.8.5"
		},
		pnpm: { peerDependencyRules: { ignoreMissing: ["vite"] } }
	};
	const ignores = [
		"catalog:",
		"file:",
		"workspace:"
	];
	for (const dep of mockDeps) {
		const version$1 = dependents[dep];
		if (!version$1 || ignores.some((ignore) => version$1.startsWith(ignore))) {
			const info = getPackageInfoSync(dep);
			mockPkg.dependencies[dep] = info?.version ? `^${info.version}` : "latest";
		} else mockPkg.dependencies[dep] = "latest";
	}
	return JSON.stringify(mockPkg, null, 2);
}

//#endregion
//#region src/build/serverEntryCode.ts
function generatorServerEntryCode({ proxies, wsProxies, cookiesOptions, bodyParserOptions, priority, build }) {
	const { serverPort, log } = build;
	return `import { createServer } from 'node:http';
import connect from 'connect';
import corsMiddleware from 'cors';
import { createMockMiddleware, createLogger, mockWebSocket } from 'vite-plugin-mock-dev-server/server';
import mockData from './mock-data.js';

const app = connect();
const server = createServer(app);
const logger = createLogger('mock-server', '${log}');
const proxies = ${JSON.stringify(proxies)};
const wsProxies = ${JSON.stringify(wsProxies)};
const cookiesOptions = ${JSON.stringify(cookiesOptions)};
const bodyParserOptions = ${JSON.stringify(bodyParserOptions)};
const priority = ${JSON.stringify(priority)};
const compiler = { mockData }

mockWebSocket(compiler, server, { wsProxies, cookiesOptions, logger });

app.use(corsMiddleware());
app.use(createMockMiddleware(compiler, {
  formidableOptions: { multiples: true },
  proxies,
  priority,
  cookiesOptions,
  bodyParserOptions,
  logger,
}));

server.listen(${serverPort});

console.log('listen: http://localhost:${serverPort}');
`;
}

//#endregion
//#region src/build/generate.ts
async function generateMockServer(ctx, options) {
	const include = toArray(options.include);
	const exclude = toArray(options.exclude);
	const cwd = options.cwd || process.cwd();
	const dir = options.dir;
	const pkg = await loadPackageJSON(options.context) || {};
	const outputDir = options.build.dist;
	const content = await generateMockEntryCode(cwd, dir, include, exclude);
	const mockEntry = path.join(cwd, `mock-data-${Date.now()}.js`);
	await fsp.writeFile(mockEntry, content, "utf-8");
	const { code, deps } = await transform(mockEntry, options);
	const mockDeps = getMockDependencies(deps, options.alias);
	await fsp.unlink(mockEntry);
	const outputList = [
		{
			filename: path.join(outputDir, "mock-data.js"),
			source: code
		},
		{
			filename: path.join(outputDir, "index.js"),
			source: generatorServerEntryCode(options)
		},
		{
			filename: path.join(outputDir, "package.json"),
			source: generatePackageJson(pkg, mockDeps)
		}
	];
	try {
		if (path.isAbsolute(outputDir)) {
			for (const { filename } of outputList) if (fs.existsSync(filename)) await fsp.rm(filename);
			options.logger.info(`${ansis.green("✓")} generate mock server in ${ansis.cyan(outputDir)}`);
			for (const { filename, source } of outputList) {
				fs.mkdirSync(path.dirname(filename), { recursive: true });
				await fsp.writeFile(filename, source, "utf-8");
				const sourceSize = (source.length / 1024).toFixed(2);
				const name$1 = path.relative(outputDir, filename);
				const space = name$1.length < 30 ? " ".repeat(30 - name$1.length) : "";
				options.logger.info(`  ${ansis.green(name$1)}${space}${ansis.bold.dim(`${sourceSize} kB`)}`);
			}
		} else for (const { filename, source } of outputList) ctx.emitFile({
			type: "asset",
			fileName: filename,
			source
		});
	} catch (e) {
		console.error(e);
	}
}

//#endregion
//#region src/core/corsMiddleware.ts
function createCorsMiddleware(compiler, { proxies, cors: corsOptions }) {
	return !corsOptions ? void 0 : function(req, res, next) {
		const { pathname } = urlParse(req.url);
		if (!pathname || proxies.length === 0 || !proxies.some((context) => doesProxyContextMatchUrl(context, req.url))) return next();
		const mockData = compiler.mockData;
		const mockUrl = Object.keys(mockData).find((pattern) => isPathMatch(pattern, pathname));
		if (!mockUrl) return next();
		cors(corsOptions)(req, res, next);
	};
}

//#endregion
//#region src/core/define.ts
function viteDefine(config) {
	const processNodeEnv = {};
	const nodeEnv = process.env.NODE_ENV || config.mode;
	Object.assign(processNodeEnv, {
		"process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"global.process.env.NODE_ENV": JSON.stringify(nodeEnv),
		"globalThis.process.env.NODE_ENV": JSON.stringify(nodeEnv)
	});
	const userDefine = {};
	const userDefineEnv = {};
	for (const key in config.define) {
		const val = config.define[key];
		const isMetaEnv = key.startsWith("import.meta.env.");
		if (typeof val === "string") {
			if (canJsonParse(val)) {
				userDefine[key] = val;
				if (isMetaEnv) userDefineEnv[key.slice(16)] = val;
			}
		} else {
			userDefine[key] = handleDefineValue(val);
			if (isMetaEnv) userDefineEnv[key.slice(16)] = val;
		}
	}
	const importMetaKeys = {};
	const importMetaEnvKeys = {};
	const importMetaFallbackKeys = {};
	importMetaKeys["import.meta.hot"] = `undefined`;
	for (const key in config.env) {
		const val = JSON.stringify(config.env[key]);
		importMetaKeys[`import.meta.env.${key}`] = val;
		importMetaEnvKeys[key] = val;
	}
	importMetaFallbackKeys["import.meta.env"] = `undefined`;
	const define = {
		...processNodeEnv,
		...importMetaKeys,
		...userDefine,
		...importMetaFallbackKeys
	};
	if ("import.meta.env" in define) define["import.meta.env"] = serializeDefine({
		...importMetaEnvKeys,
		...userDefineEnv
	});
	return define;
}
/**
* Like `JSON.stringify` but keeps raw string values as a literal
* in the generated code. For example: `"window"` would refer to
* the global `window` object directly.
*/
function serializeDefine(define) {
	let res = `{`;
	const keys = Object.keys(define);
	for (let i = 0; i < keys.length; i++) {
		const key = keys[i];
		const val = define[key];
		res += `${JSON.stringify(key)}: ${handleDefineValue(val)}`;
		if (i !== keys.length - 1) res += `, `;
	}
	return `${res}}`;
}
function handleDefineValue(value) {
	if (typeof value === "undefined") return "undefined";
	if (typeof value === "string") return value;
	return JSON.stringify(value);
}
function canJsonParse(value) {
	try {
		JSON.parse(value);
		return true;
	} catch {
		return false;
	}
}

//#endregion
//#region src/core/init.ts
function initMockMiddlewares(options, server, ws) {
	/**
	* 加载 mock 文件, 包括监听 mock 文件的依赖文件变化，
	* 并注入 vite  `define` / `alias`
	*/
	const compiler = new Compiler(options);
	compiler.run(!!server);
	/**
	* 监听 mock 文件是否发生变更，如何配置了 reload 为 true，
	* 当发生变更时，通知当前页面进行重新加载
	*/
	compiler.on("mock:update-end", () => {
		if (options.reload) ws?.send({ type: "full-reload" });
	});
	server?.on("close", () => compiler.close());
	/**
	* 虽然 config.server.proxy 中有关于 ws 的代理配置，
	* 但是由于 vite 内部在启动时，直接对 ws相关的请求，通过 upgrade 事件，发送给 http-proxy
	* 的 ws 代理方法。如果插件直接使用 config.server.proxy 中的 ws 配置，
	* 就会导致两次 upgrade 事件 对 wss 实例的冲突。
	* 由于 vite 内部并没有提供其他的方式跳过 内部 upgrade 的方式，（个人认为也没有必要提供此类方式）
	* 所以插件选择了通过插件的配置项 `wsPrefix` 来做 判断的首要条件。
	* 当前插件默认会将已配置在 wsPrefix 的值，从 config.server.proxy 的删除，避免发生冲突问题。
	*/
	mockWebSocket(compiler, server, options);
	const middlewares = [];
	middlewares.push(
		/**
		* 在 vite 的开发服务中，由于插件 的 enforce 为 `pre`，
		* mock 中间件的执行顺序 早于 vite 内部的 cors 中间件执行,
		* 这导致了 vite 默认开启的 cors 对 mock 请求不生效。
		* 在一些比如 微前端项目、或者联合项目中，会由于端口不一致而导致跨域问题。
		* 所以在这里，使用 cors 中间件 来解决这个问题。
		*
		* 同时为了使 插件内的 cors 和 vite 的 cors 不产生冲突，并拥有一致的默认行为，
		* 也会使用 viteConfig.server.cors 配置，并支持 用户可以对 mock 中的 cors 中间件进行配置。
		* 而用户的配置也仅对 mock 的接口生效。
		*/
		createCorsMiddleware(compiler, options),
		createMockMiddleware(compiler, options)
	);
	return middlewares.filter(Boolean);
}

//#endregion
//#region src/options.ts
function resolvePluginOptions({ prefix = [], wsPrefix = [], cwd, dir = "mock", include = ["**/*.mock.{js,ts,cjs,mjs,json,json5}"], exclude = [], reload = false, log = "info", cors: cors$1 = true, formidableOptions = {}, build = false, cookiesOptions = {}, bodyParserOptions = {}, priority = {} }, config) {
	const logger = createLogger("vite:mock", isBoolean(log) ? log ? "info" : "error" : log);
	const { httpProxies } = ensureProxies(config.server.proxy || {});
	const proxies = uniq([...toArray(prefix), ...httpProxies]);
	const wsProxies = toArray(wsPrefix);
	if (!proxies.length && !wsProxies.length) logger.warn(`No proxy was configured, mock server will not work. See ${ansis.cyan("https://vite-plugin-mock-dev-server.netlify.app/guide/usage")}`);
	const enabled = cors$1 === false ? false : config.server.cors !== false;
	let corsOptions = {};
	if (enabled && config.server.cors !== false) corsOptions = {
		...corsOptions,
		...typeof config.server.cors === "boolean" ? {} : config.server.cors
	};
	if (enabled && cors$1 !== false) corsOptions = {
		...corsOptions,
		...typeof cors$1 === "boolean" ? {} : cors$1
	};
	const alias = [];
	const aliasConfig = config.resolve.alias || [];
	if (isArray(aliasConfig)) alias.push(...aliasConfig);
	else Object.entries(aliasConfig).forEach(([find, replacement]) => {
		alias.push({
			find,
			replacement
		});
	});
	return {
		cwd: cwd || process.cwd(),
		dir,
		include,
		exclude,
		context: config.root,
		reload,
		cors: enabled ? corsOptions : false,
		cookiesOptions,
		log,
		formidableOptions: {
			multiples: true,
			...formidableOptions
		},
		bodyParserOptions,
		priority,
		build: build ? {
			serverPort: 8080,
			dist: "mockServer",
			log: "error",
			...typeof build === "object" ? build : {}
		} : false,
		proxies,
		wsProxies,
		logger,
		alias,
		define: viteDefine(config)
	};
}
function ensureProxies(serverProxy = {}) {
	const httpProxies = [];
	const wsProxies = [];
	Object.keys(serverProxy).forEach((key) => {
		const value = serverProxy[key];
		if (typeof value === "string" || !value.ws && !value.target?.toString().startsWith("ws:") && !value.target?.toString().startsWith("wss:")) httpProxies.push(key);
		else wsProxies.push(key);
	});
	return {
		httpProxies,
		wsProxies
	};
}

//#endregion
//#region src/plugin.ts
function mockDevServerPlugin(options = {}) {
	const plugins = [serverPlugin(options)];
	if (options.build) plugins.push(buildPlugin(options));
	return plugins;
}
function buildPlugin(options) {
	let viteConfig = {};
	let resolvedOptions;
	return {
		name: "vite-plugin-mock-dev-server-generator",
		enforce: "post",
		apply: "build",
		configResolved(config) {
			viteConfig = config;
			resolvedOptions = resolvePluginOptions(options, config);
			config.logger.warn("");
		},
		async buildEnd(error) {
			if (error || viteConfig.command !== "build") return;
			await generateMockServer(this, resolvedOptions);
		}
	};
}
function serverPlugin(options) {
	let resolvedOptions;
	return {
		name: "vite-plugin-mock-dev-server",
		enforce: "pre",
		apply: "serve",
		config(config) {
			const wsPrefix = toArray(options.wsPrefix);
			if (wsPrefix.length && config.server?.proxy) {
				const proxy = {};
				Object.keys(config.server.proxy).forEach((key) => {
					if (!wsPrefix.includes(key)) proxy[key] = config.server.proxy[key];
				});
				config.server.proxy = proxy;
			}
			recoverRequest(config);
		},
		configResolved(config) {
			resolvedOptions = resolvePluginOptions(options, config);
			config.logger.warn("");
		},
		configureServer({ middlewares, httpServer, ws }) {
			const middlewareList = initMockMiddlewares(resolvedOptions, httpServer, ws);
			middlewareList.forEach((middleware) => middlewares.use(middleware));
		},
		configurePreviewServer({ middlewares, httpServer }) {
			const middlewareList = initMockMiddlewares(resolvedOptions, httpServer);
			middlewareList.forEach((middleware) => middlewares.use(middleware));
		}
	};
}

//#endregion
export { createDefineMock, createLogger, createMockMiddleware, createSSEStream, defineMock, defineMockData, logLevels, mockDevServerPlugin, mockWebSocket, processMockData, processRawData, sortByValidator };