import { hasOwn, isArray, isBoolean, isEmptyObject, isFunction, isPlainObject, random, sleep, sortBy, timestamp, toArray, uniq } from "@pengzhanbo/utils";
import path from "node:path";
import ansis from "ansis";
import picomatch from "picomatch";
import { match, parse, pathToRegexp } from "path-to-regexp";
import os from "node:os";
import Debug from "debug";
import { parse as parse$1 } from "node:querystring";
import bodyParser from "co-body";
import formidable from "formidable";
import Cookies from "cookies";
import { Buffer } from "node:buffer";
import HTTP_STATUS from "http-status";
import * as mime from "mime-types";
import { WebSocketServer } from "ws";

//#region src/utils/createMatcher.ts
function createMatcher(include, exclude) {
	const pattern = [];
	const ignore = ["**/node_modules/**", ...toArray(exclude)];
	toArray(include).forEach((item) => {
		if (item[0] === "!") ignore.push(item.slice(1));
		else pattern.push(item);
	});
	const isMatch = picomatch(pattern, { ignore });
	return {
		pattern,
		ignore,
		isMatch
	};
}

//#endregion
//#region src/utils/doesProxyContextMatchUrl.ts
function doesProxyContextMatchUrl(context, url) {
	return context[0] === "^" && new RegExp(context).test(url) || url.startsWith(context);
}

//#endregion
//#region src/utils/is.ts
function isStream(stream) {
	return stream !== null && typeof stream === "object" && typeof stream.pipe === "function";
}
function isReadableStream(stream) {
	return isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
}
const PACKAGE_CACHE = {};
async function isPackageExists(mod) {
	if (hasOwn(PACKAGE_CACHE, mod)) return PACKAGE_CACHE[mod];
	try {
		if (import.meta.resolve) PACKAGE_CACHE[mod] = !!import.meta.resolve(mod);
		else {
			await import(mod);
			PACKAGE_CACHE[mod] = true;
		}
		return PACKAGE_CACHE[mod];
	} catch {}
	PACKAGE_CACHE[mod] = false;
	return false;
}

//#endregion
//#region src/utils/isObjectSubset.ts
/**
* Checks if target object is a subset of source object.
* That is, all properties and their corresponding values in target exist in source.
*
* 深度比较两个对象之间，target 是否属于 source 的子集，
* 即 target 的所有属性和对应的值，都在 source 中，
*/
function isObjectSubset(source, target) {
	if (!target) return true;
	for (const key in target) if (!isIncluded(source[key], target[key])) return false;
	return true;
}
function isIncluded(source, target) {
	if (isArray(source) && isArray(target)) {
		const seen = /* @__PURE__ */ new Set();
		return target.every((ti) => source.some((si, i) => {
			if (seen.has(i)) return false;
			const included = isIncluded(si, ti);
			if (included) seen.add(i);
			return included;
		}));
	}
	if (isPlainObject(source) && isPlainObject(target)) return isObjectSubset(source, target);
	return Object.is(source, target);
}

//#endregion
//#region src/utils/isPathMatch.ts
const cache$1 = /* @__PURE__ */ new Map();
/**
* 判断 path 是否匹配 pattern
*/
function isPathMatch(pattern, path$1) {
	let regexp = cache$1.get(pattern);
	if (!regexp) {
		regexp = pathToRegexp(pattern).regexp;
		cache$1.set(pattern, regexp);
	}
	return regexp.test(path$1);
}

//#endregion
//#region src/utils/logger.ts
const logLevels = {
	silent: 0,
	error: 1,
	warn: 2,
	info: 3,
	debug: 4
};
function createLogger(prefix, defaultLevel = "info") {
	prefix = `[${prefix}]`;
	function output(type, msg, level) {
		level = isBoolean(level) ? level ? defaultLevel : "error" : level;
		const thresh = logLevels[level];
		if (thresh >= logLevels[type]) {
			const method = type === "info" || type === "debug" ? "log" : type;
			const tag = type === "debug" ? ansis.magenta.bold(prefix) : type === "info" ? ansis.cyan.bold(prefix) : type === "warn" ? ansis.yellow.bold(prefix) : ansis.red.bold(prefix);
			const format = `${ansis.dim((/* @__PURE__ */ new Date()).toLocaleTimeString())} ${tag} ${msg}`;
			console[method](format);
		}
	}
	const logger = {
		debug(msg, level = defaultLevel) {
			output("debug", msg, level);
		},
		info(msg, level = defaultLevel) {
			output("info", msg, level);
		},
		warn(msg, level = defaultLevel) {
			output("warn", msg, level);
		},
		error(msg, level = defaultLevel) {
			output("error", msg, level);
		}
	};
	return logger;
}

//#endregion
//#region src/utils/shared.ts
const debug = Debug("vite:mock-dev-server");
const windowsSlashRE = /\\/g;
const isWindows = os.platform() === "win32";
function slash(p) {
	return p.replace(windowsSlashRE, "/");
}
function normalizePath(id) {
	return path.posix.normalize(isWindows ? slash(id) : id);
}

//#endregion
//#region src/utils/urlParse.ts
/**
* nodejs 从 19.0.0 开始 弃用 url.parse，因此使用 url.parse 来解析 可能会报错，
* 使用 URL 来解析
*/
function urlParse(input) {
	const url = new URL(input, "http://example.com");
	const pathname = decodeURIComponent(url.pathname);
	const query = parse$1(url.search.replace(/^\?/, ""));
	return {
		pathname,
		query
	};
}

//#endregion
//#region src/compiler/processData.ts
function processRawData(raw, __filepath__) {
	let res;
	if (isArray(raw)) res = raw.map((item) => ({
		...item,
		__filepath__
	}));
	else if ("url" in raw) res = {
		...raw,
		__filepath__
	};
	else {
		res = [];
		Object.keys(raw).forEach((key) => {
			const data = raw[key];
			if (isArray(data)) res.push(...data.map((item) => ({
				...item,
				__filepath__
			})));
			else res.push({
				...data,
				__filepath__
			});
		});
	}
	return res;
}
function processMockData(mockList) {
	const list = [];
	for (const [, handle] of mockList.entries()) if (handle) list.push(...toArray(handle));
	const mocks = {};
	list.filter((mock) => isPlainObject(mock) && mock.enabled !== false && mock.url).forEach((mock) => {
		const { pathname, query } = urlParse(mock.url);
		const list$1 = mocks[pathname] ??= [];
		const current = {
			...mock,
			url: pathname
		};
		if (current.ws !== true) {
			const validator = current.validator;
			if (!isEmptyObject(query)) if (isFunction(validator)) current.validator = function(request) {
				return isObjectSubset(request.query, query) && validator(request);
			};
			else if (validator) {
				current.validator = { ...validator };
				current.validator.query = current.validator.query ? {
					...query,
					...current.validator.query
				} : query;
			} else current.validator = { query };
		}
		list$1.push(current);
	});
	Object.keys(mocks).forEach((key) => {
		mocks[key] = sortByValidator(mocks[key]);
	});
	return mocks;
}
function sortByValidator(mocks) {
	return sortBy(mocks, (item) => {
		if (item.ws === true) return 0;
		const { validator } = item;
		if (!validator || isEmptyObject(validator)) return 2;
		if (isFunction(validator)) return 0;
		const count = Object.keys(validator).reduce((prev, key) => prev + keysCount(validator[key]), 0);
		return 1 / count;
	});
}
function keysCount(obj) {
	if (!obj) return 0;
	return Object.keys(obj).length;
}

//#endregion
//#region src/core/request.ts
/**
* 解析请求体 request.body
*/
async function parseRequestBody(req, formidableOptions, bodyParserOptions = {}) {
	const method = req.method.toUpperCase();
	if (["HEAD", "OPTIONS"].includes(method)) return void 0;
	const type = req.headers["content-type"]?.toLocaleLowerCase() || "";
	const { limit, formLimit, jsonLimit, textLimit,...rest } = bodyParserOptions;
	try {
		if (type.startsWith("application/json")) return await bodyParser.json(req, {
			limit: jsonLimit || limit,
			...rest
		});
		if (type.startsWith("application/x-www-form-urlencoded")) return await bodyParser.form(req, {
			limit: formLimit || limit,
			...rest
		});
		if (type.startsWith("text/plain")) return await bodyParser.text(req, {
			limit: textLimit || limit,
			...rest
		});
		if (type.startsWith("multipart/form-data")) return await parseRequestBodyWithMultipart(req, formidableOptions);
	} catch (e) {
		console.error(e);
	}
	return void 0;
}
const DEFAULT_FORMIDABLE_OPTIONS = {
	keepExtensions: true,
	filename(name, ext, part) {
		return part?.originalFilename || `${name}.${Date.now()}${ext ? `.${ext}` : ""}`;
	}
};
/**
* 解析 request form multipart body
*/
async function parseRequestBodyWithMultipart(req, options) {
	const form = formidable({
		...DEFAULT_FORMIDABLE_OPTIONS,
		...options
	});
	return new Promise((resolve, reject) => {
		form.parse(req, (error, fields, files) => {
			if (error) {
				reject(error);
				return;
			}
			resolve({
				...fields,
				...files
			});
		});
	});
}
const matcherCache = /* @__PURE__ */ new Map();
/**
* 解析请求 url 中的动态参数 params
*/
function parseRequestParams(pattern, url) {
	let matcher = matcherCache.get(pattern);
	if (!matcher) {
		matcher = match(pattern, { decode: decodeURIComponent });
		matcherCache.set(pattern, matcher);
	}
	const matched = matcher(url);
	return matched ? matched.params : {};
}
/**
* 验证请求是否符合 validator
*/
function requestValidate(request, validator) {
	return isObjectSubset(request.headers, validator.headers) && isObjectSubset(request.body, validator.body) && isObjectSubset(request.params, validator.params) && isObjectSubset(request.query, validator.query) && isObjectSubset(request.refererQuery, validator.refererQuery);
}
function formatLog(prefix, data) {
	return !data || isEmptyObject(data) ? "" : `  ${ansis.gray(`${prefix}:`)}${JSON.stringify(data)}`;
}
function requestLog(request, filepath) {
	const { url, method, query, params, body } = request;
	let { pathname } = new URL(url, "http://example.com");
	pathname = ansis.green(decodeURIComponent(pathname));
	const ms = ansis.magenta.bold(method);
	const qs = formatLog("query", query);
	const ps = formatLog("params", params);
	const bs = formatLog("body", body);
	const file = `  ${ansis.dim.underline(`(${filepath})`)}`;
	return `${ms} ${pathname}${qs}${ps}${bs}${file}`;
}

//#endregion
//#region src/core/findMockData.ts
/**
* 查找匹配的 mock data
*/
function fineMockData(mockList, logger, { pathname, method, request }) {
	return mockList.find((mock) => {
		if (!pathname || !mock || !mock.url || mock.ws) return false;
		const methods = mock.method ? isArray(mock.method) ? mock.method : [mock.method] : ["GET", "POST"];
		if (!methods.includes(method)) return false;
		const hasMock = isPathMatch(mock.url, pathname);
		if (hasMock && mock.validator) {
			const params = parseRequestParams(mock.url, pathname);
			if (isFunction(mock.validator)) return mock.validator({
				params,
				...request
			});
			else try {
				return requestValidate({
					params,
					...request
				}, mock.validator);
			} catch (e) {
				const file = mock.__filepath__;
				logger.error(`${ansis.red(`mock error at ${pathname}`)}\n${e}\n  at validator (${ansis.underline(file)})`, mock.log);
				return false;
			}
		}
		return hasMock;
	});
}

//#endregion
//#region src/core/matchingWeight.ts
const tokensCache = {};
function getTokens(rule) {
	if (tokensCache[rule]) return tokensCache[rule];
	const res = [];
	const flatten = (tokens, group = false) => {
		for (const token of tokens) if (token.type === "text") {
			const sub = token.value.split("/").filter(Boolean);
			sub.length && res.push(...sub.map((v) => ({
				type: "text",
				value: v
			})));
		} else if (token.type === "group") flatten(token.tokens, true);
		else {
			if (group) token.optional = true;
			res.push(token);
		}
	};
	flatten(parse(rule).tokens);
	tokensCache[rule] = res;
	return res;
}
function getHighest(rules) {
	let weights = rules.map((rule) => getTokens(rule).length);
	weights = weights.length === 0 ? [1] : weights;
	return Math.max(...weights) + 2;
}
function sortFn(rule) {
	const tokens = getTokens(rule);
	let w = 0;
	for (let i = 0; i < tokens.length; i++) {
		const token = tokens[i];
		if (token.type !== "text") w += 10 ** (i + 1);
		w += 10 ** (i + 1);
	}
	return w;
}
function preSort(rules) {
	let matched = [];
	const preMatch = [];
	for (const rule of rules) {
		const tokens = getTokens(rule);
		const len = tokens.filter((token) => token.type !== "text").length;
		if (!preMatch[len]) preMatch[len] = [];
		preMatch[len].push(rule);
	}
	for (const match$1 of preMatch.filter((v) => v && v.length > 0)) matched = [...matched, ...sortBy(match$1, sortFn).reverse()];
	return matched;
}
function defaultPriority(rules) {
	const highest = getHighest(rules);
	return sortBy(rules, (rule) => {
		const tokens = getTokens(rule);
		const dym = tokens.filter((token) => token.type !== "text");
		if (dym.length === 0) return 0;
		let weight = dym.length;
		let exp = 0;
		for (let i = 0; i < tokens.length; i++) {
			const token = tokens[i];
			const isDynamic = token.type !== "text";
			const isWildcard = token.type === "wildcard";
			const isOptional = !!token.optional;
			exp += isDynamic ? 1 : 0;
			if (i === tokens.length - 1 && isWildcard) weight += (isOptional ? 5 : 4) * 10 ** (tokens.length === 1 ? highest + 1 : highest);
			else {
				if (isWildcard) weight += 3 * 10 ** (highest - 1);
				else weight += 2 * 10 ** exp;
				if (isOptional) weight += 10 ** exp;
			}
		}
		return weight;
	});
}
function matchingWeight(rules, url, priority) {
	let matched = defaultPriority(preSort(rules.filter((rule) => isPathMatch(rule, url))));
	const { global = [], special = {} } = priority;
	if (global.length === 0 && isEmptyObject(special) || matched.length === 0) return matched;
	const [statics, dynamics] = twoPartMatch(matched);
	const globalMatch = global.filter((rule) => dynamics.includes(rule));
	if (globalMatch.length > 0) matched = uniq([
		...statics,
		...globalMatch,
		...dynamics
	]);
	if (isEmptyObject(special)) return matched;
	const specialRule = Object.keys(special).filter((rule) => matched.includes(rule))[0];
	if (!specialRule) return matched;
	const options = special[specialRule];
	const { rules: lowerRules, when } = isArray(options) ? {
		rules: options,
		when: []
	} : options;
	if (lowerRules.includes(matched[0])) {
		if (when.length === 0 || when.some((path$1) => pathToRegexp(path$1).regexp.test(url))) matched = uniq([specialRule, ...matched]);
	}
	return matched;
}
/**
* 将规则分为静态和动态两部分
*/
function twoPartMatch(rules) {
	const statics = [];
	const dynamics = [];
	for (const rule of rules) {
		const tokens = getTokens(rule);
		const dym = tokens.filter((token) => token.type !== "text");
		if (dym.length > 0) dynamics.push(rule);
		else statics.push(rule);
	}
	return [statics, dynamics];
}

//#endregion
//#region src/core/requestRecovery.ts
const cache = /* @__PURE__ */ new WeakMap();
/**
* 备份请求数据
*/
function collectRequest(req) {
	const chunks = [];
	req.addListener("data", (chunk) => {
		chunks.push(Buffer.from(chunk));
	});
	req.addListener("end", () => {
		if (chunks.length) cache.set(req, Buffer.concat(chunks));
	});
}
/**
* vite 在 proxy 配置中，允许通过 configure 访问 http-proxy 实例，
* 通过 http-proxy 的 proxyReq 事件，重新写入请求流
*/
function recoverRequest(config) {
	if (!config.server) return;
	const proxies = config.server.proxy || {};
	Object.keys(proxies).forEach((key) => {
		const target = proxies[key];
		const options = typeof target === "string" ? { target } : target;
		if (options.ws) return;
		const { configure,...rest } = options;
		proxies[key] = {
			...rest,
			configure(proxy, options$1) {
				configure?.(proxy, options$1);
				proxy.on("proxyReq", (proxyReq, req) => {
					const buffer = cache.get(req);
					if (buffer) {
						cache.delete(req);
						/**
						* 使用 http-proxy 的 agent 配置会提前写入代理请求流
						* https://github.com/http-party/node-http-proxy/issues/1287
						*/
						if (!proxyReq.headersSent) proxyReq.setHeader("Content-Length", buffer.byteLength);
						if (!proxyReq.writableEnded) proxyReq.write(buffer);
					}
				});
			}
		};
	});
}

//#endregion
//#region src/core/response.ts
/**
* 根据状态码获取状态文本
*/
function getHTTPStatusText(status) {
	return HTTP_STATUS[status] || "Unknown";
}
/**
* 设置响应状态
*/
function provideResponseStatus(response, status = 200, statusText) {
	response.statusCode = status;
	response.statusMessage = statusText || getHTTPStatusText(status);
}
/**
* 设置响应头
*/
async function provideResponseHeaders(req, res, mock, logger) {
	const { headers, type = "json" } = mock;
	const filepath = mock.__filepath__;
	const contentType = mime.contentType(type) || mime.contentType(mime.lookup(type) || "");
	if (contentType) res.setHeader("Content-Type", contentType);
	res.setHeader("Cache-Control", "no-cache,max-age=0");
	res.setHeader("X-Mock-Power-By", "vite-plugin-mock-dev-server");
	if (filepath) res.setHeader("X-File-Path", filepath);
	if (!headers) return;
	try {
		const raw = isFunction(headers) ? await headers(req) : headers;
		Object.keys(raw).forEach((key) => {
			res.setHeader(key, raw[key]);
		});
	} catch (e) {
		logger.error(`${ansis.red(`mock error at ${req.url.split("?")[0]}`)}\n${e}\n  at headers (${ansis.underline(filepath)})`, mock.log);
	}
}
/**
* 设置响应cookie
*/
async function provideResponseCookies(req, res, mock, logger) {
	const { cookies } = mock;
	const filepath = mock.__filepath__;
	if (!cookies) return;
	try {
		const raw = isFunction(cookies) ? await cookies(req) : cookies;
		Object.keys(raw).forEach((key) => {
			const cookie = raw[key];
			if (isArray(cookie)) {
				const [value, options] = cookie;
				res.setCookie(key, value, options);
			} else res.setCookie(key, cookie);
		});
	} catch (e) {
		logger.error(`${ansis.red(`mock error at ${req.url.split("?")[0]}`)}\n${e}\n  at cookies (${ansis.underline(filepath)})`, mock.log);
	}
}
/**
* 设置响应数据
*/
function sendResponseData(res, raw, type) {
	if (isReadableStream(raw)) raw.pipe(res);
	else if (Buffer.isBuffer(raw)) res.end(type === "text" || type === "json" ? raw.toString("utf-8") : raw);
	else {
		const content = typeof raw === "string" ? raw : JSON.stringify(raw);
		res.end(type === "buffer" ? Buffer.from(content) : content);
	}
}
/**
* 实际响应延迟
*/
async function responseRealDelay(startTime, delay) {
	if (!delay || typeof delay === "number" && delay <= 0 || isArray(delay) && delay.length !== 2) return;
	let realDelay = 0;
	if (isArray(delay)) {
		const [min, max] = delay;
		realDelay = random(min, max);
	} else realDelay = delay - (timestamp() - startTime);
	if (realDelay > 0) await sleep(realDelay);
}

//#endregion
//#region src/core/mockMiddleware.ts
function createMockMiddleware(compiler, { formidableOptions = {}, bodyParserOptions = {}, proxies, cookiesOptions, logger, priority = {} }) {
	return async function mockMiddleware(req, res, next) {
		const startTime = timestamp();
		const { query, pathname } = urlParse(req.url);
		if (!pathname || proxies.length === 0 || !proxies.some((context) => doesProxyContextMatchUrl(context, req.url))) return next();
		const mockData = compiler.mockData;
		const mockUrls = matchingWeight(Object.keys(mockData), pathname, priority);
		if (mockUrls.length === 0) return next();
		collectRequest(req);
		const { query: refererQuery } = urlParse(req.headers.referer || "");
		const reqBody = await parseRequestBody(req, formidableOptions, bodyParserOptions);
		const cookies = new Cookies(req, res, cookiesOptions);
		const getCookie = cookies.get.bind(cookies);
		const method = req.method.toUpperCase();
		let mock;
		let _mockUrl;
		for (const mockUrl of mockUrls) {
			mock = fineMockData(mockData[mockUrl], logger, {
				pathname,
				method,
				request: {
					query,
					refererQuery,
					body: reqBody,
					headers: req.headers,
					getCookie
				}
			});
			if (mock) {
				_mockUrl = mockUrl;
				break;
			}
		}
		if (!mock) {
			const matched = mockUrls.map((m) => m === _mockUrl ? ansis.underline.bold(m) : ansis.dim(m)).join(", ");
			logger.warn(`${ansis.green(pathname)} matches  ${matched} , but mock data is not found.`);
			return next();
		}
		const request = req;
		const response = res;
		request.body = reqBody;
		request.query = query;
		request.refererQuery = refererQuery;
		request.params = parseRequestParams(mock.url, pathname);
		request.getCookie = getCookie;
		response.setCookie = cookies.set.bind(cookies);
		const { body, delay, type = "json", response: responseFn, status = 200, statusText, log: logLevel, __filepath__: filepath } = mock;
		provideResponseStatus(response, status, statusText);
		await provideResponseHeaders(request, response, mock, logger);
		await provideResponseCookies(request, response, mock, logger);
		logger.info(requestLog(request, filepath), logLevel);
		logger.debug(`${ansis.magenta("DEBUG")} ${ansis.underline(pathname)}  matches: [ ${mockUrls.map((m) => m === _mockUrl ? ansis.underline.bold(m) : ansis.dim(m)).join(", ")} ]\n`);
		if (body) {
			try {
				const content = isFunction(body) ? await body(request) : body;
				await responseRealDelay(startTime, delay);
				sendResponseData(response, content, type);
			} catch (e) {
				logger.error(`${ansis.red(`mock error at ${pathname}`)}\n${e}\n  at body (${ansis.underline(filepath)})`, logLevel);
				provideResponseStatus(response, 500);
				res.end("");
			}
			return;
		}
		if (responseFn) {
			try {
				await responseRealDelay(startTime, delay);
				await responseFn(request, response, next);
			} catch (e) {
				logger.error(`${ansis.red(`mock error at ${pathname}`)}\n${e}\n  at response (${ansis.underline(filepath)})`, logLevel);
				provideResponseStatus(response, 500);
				res.end("");
			}
			return;
		}
		res.end("");
	};
}

//#endregion
//#region src/core/ws.ts
/**
* mock websocket
*/
function mockWebSocket(compiler, server, { wsProxies: proxies, cookiesOptions, logger }) {
	const hmrMap = /* @__PURE__ */ new Map();
	const poolMap = /* @__PURE__ */ new Map();
	const wssContextMap = /* @__PURE__ */ new WeakMap();
	const getWssMap = (mockUrl) => {
		let wssMap = poolMap.get(mockUrl);
		if (!wssMap) poolMap.set(mockUrl, wssMap = /* @__PURE__ */ new Map());
		return wssMap;
	};
	const getWss = (wssMap, pathname) => {
		let wss = wssMap.get(pathname);
		if (!wss) wssMap.set(pathname, wss = new WebSocketServer({ noServer: true }));
		return wss;
	};
	const addHmr = (filepath, mockUrl) => {
		let urlList = hmrMap.get(filepath);
		if (!urlList) hmrMap.set(filepath, urlList = /* @__PURE__ */ new Set());
		urlList.add(mockUrl);
	};
	const setupWss = (wssMap, wss, mock, context, pathname, filepath) => {
		try {
			mock.setup?.(wss, context);
			wss.on("close", () => wssMap.delete(pathname));
			wss.on("error", (e) => {
				logger.error(`${ansis.red(`WebSocket mock error at ${wss.path}`)}\n${e}\n  at setup (${filepath})`, mock.log);
			});
		} catch (e) {
			logger.error(`${ansis.red(`WebSocket mock error at ${wss.path}`)}\n${e}\n  at setup (${filepath})`, mock.log);
		}
	};
	const emitConnection = (wss, ws, req, connectionList) => {
		wss.emit("connection", ws, req);
		ws.on("close", () => {
			const i = connectionList.findIndex((item) => item.ws === ws);
			if (i !== -1) connectionList.splice(i, 1);
		});
	};
	const restartWss = (wssMap, wss, mock, pathname, filepath) => {
		const { cleanupList, connectionList, context } = wssContextMap.get(wss);
		cleanupRunner(cleanupList);
		connectionList.forEach(({ ws }) => ws.removeAllListeners());
		wss.removeAllListeners();
		setupWss(wssMap, wss, mock, context, pathname, filepath);
		connectionList.forEach(({ ws, req }) => emitConnection(wss, ws, req, connectionList));
	};
	compiler.on?.("mock:update-end", (filepath) => {
		if (!hmrMap.has(filepath)) return;
		const mockUrlList = hmrMap.get(filepath);
		if (!mockUrlList) return;
		for (const mockUrl of mockUrlList.values()) for (const mock of compiler.mockData[mockUrl]) {
			if (!mock.ws || mock.__filepath__ !== filepath) return;
			const wssMap = getWssMap(mockUrl);
			for (const [pathname, wss] of wssMap.entries()) restartWss(wssMap, wss, mock, pathname, filepath);
		}
	});
	server?.on("upgrade", (req, socket, head) => {
		const { pathname, query } = urlParse(req.url);
		if (!pathname || proxies.length === 0 || !proxies.some((context) => doesProxyContextMatchUrl(context, req.url))) return;
		const mockData = compiler.mockData;
		const mockUrl = Object.keys(mockData).find((key) => isPathMatch(key, pathname));
		if (!mockUrl) return;
		const mock = mockData[mockUrl].find((mock$1) => {
			return mock$1.url && mock$1.ws && isPathMatch(mock$1.url, pathname);
		});
		if (!mock) return;
		const filepath = mock.__filepath__;
		addHmr(filepath, mockUrl);
		const wssMap = getWssMap(mockUrl);
		const wss = getWss(wssMap, pathname);
		let wssContext = wssContextMap.get(wss);
		if (!wssContext) {
			const cleanupList = [];
			const context = { onCleanup: (cleanup) => cleanupList.push(cleanup) };
			wssContext = {
				cleanupList,
				context,
				connectionList: []
			};
			wssContextMap.set(wss, wssContext);
			setupWss(wssMap, wss, mock, context, pathname, filepath);
		}
		const request = req;
		const cookies = new Cookies(req, req, cookiesOptions);
		const { query: refererQuery } = urlParse(req.headers.referer || "");
		request.query = query;
		request.refererQuery = refererQuery;
		request.params = parseRequestParams(mockUrl, pathname);
		request.getCookie = cookies.get.bind(cookies);
		wss.handleUpgrade(request, socket, head, (ws) => {
			logger.info(`${ansis.magenta.bold("WebSocket")} ${ansis.green(req.url)} connected ${ansis.dim(`(${filepath})`)}`, mock.log);
			wssContext.connectionList.push({
				req: request,
				ws
			});
			emitConnection(wss, ws, request, wssContext.connectionList);
		});
	});
	server?.on("close", () => {
		for (const wssMap of poolMap.values()) {
			for (const wss of wssMap.values()) {
				const wssContext = wssContextMap.get(wss);
				cleanupRunner(wssContext.cleanupList);
				wss.close();
			}
			wssMap.clear();
		}
		poolMap.clear();
		hmrMap.clear();
	});
}
function cleanupRunner(cleanupList) {
	let cleanup;
	while (cleanup = cleanupList.shift()) cleanup?.();
}

//#endregion
export { createLogger, createMatcher, createMockMiddleware, debug, doesProxyContextMatchUrl, isPackageExists, isPathMatch, logLevels, mockWebSocket, normalizePath, processMockData, processRawData, recoverRequest, sortByValidator, urlParse };