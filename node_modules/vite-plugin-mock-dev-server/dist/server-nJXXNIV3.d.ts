import { LogLevel, MockHttpItem, MockOptions, MockServerPluginOptions, MockWebsocketItem, ServerBuildOption } from "./types-BtCJqeLH.js";
import { Matcher } from "picomatch";
import EventEmitter from "node:events";
import { CorsOptions } from "cors";
import { Server } from "node:http";
import { Alias, Connect } from "vite";
import { Http2SecureServer } from "node:http2";

//#region src/compiler/types.d.ts

type MockRawData = MockOptions | MockHttpItem | MockWebsocketItem | Record<string, MockOptions | MockHttpItem | MockWebsocketItem>;
//#endregion
//#region src/compiler/processData.d.ts
declare function processRawData(raw: MockRawData, __filepath__: string): MockOptions | MockHttpItem | MockWebsocketItem;
declare function processMockData(mockList: Map<string, MockHttpItem | MockWebsocketItem | MockOptions> | (MockHttpItem | MockWebsocketItem | MockOptions)[]): Record<string, MockOptions>;
declare function sortByValidator(mocks: MockOptions): (MockHttpItem | MockWebsocketItem)[];
//#endregion
//#region src/utils/logger.d.ts
interface Logger {
  debug: (msg: string, level?: boolean | LogLevel) => void;
  info: (msg: string, level?: boolean | LogLevel) => void;
  warn: (msg: string, level?: boolean | LogLevel) => void;
  error: (msg: string, level?: boolean | LogLevel) => void;
}
declare const logLevels: Record<LogLevel, number>;
declare function createLogger(prefix: string, defaultLevel?: LogLevel): Logger;
//#endregion
//#region src/options.d.ts
type ResolvedMockServerPluginOptions = Required<Omit<MockServerPluginOptions, "build" | "cors" | "wsPrefix" | "prefix">> & {
  context: string;
  logger: Logger;
  alias: Alias[];
  define: Record<string, any>;
  proxies: string[];
  wsProxies: string[];
  build: false | ServerBuildOption;
  cors: false | CorsOptions;
};
//#endregion
//#region src/compiler/compiler.d.ts
/**
* Mock 文件加载编译，并转换为 Mock 数据
*/
declare class Compiler extends EventEmitter {
  options: ResolvedMockServerPluginOptions;
  private moduleCache;
  private moduleDeps;
  cwd: string;
  private mockWatcher;
  private depsWatcher;
  private isESM;
  private _mockData;
  constructor(options: ResolvedMockServerPluginOptions);
  get mockData(): Record<string, MockOptions>;
  run(watch?: boolean): void;
  close(): void;
  private load;
  private updateMockData;
  private updateModuleDeps;
  watchMockEntry(isMatch: Matcher): void;
  watchDeps(): void;
}
//#endregion
//#region src/core/mockMiddleware.d.ts
interface CreateMockMiddlewareOptions extends Pick<MockServerPluginOptions, "formidableOptions" | "cookiesOptions" | "bodyParserOptions" | "priority"> {
  proxies: string[];
  logger: Logger;
}
declare function createMockMiddleware(compiler: Compiler, {
  formidableOptions,
  bodyParserOptions,
  proxies,
  cookiesOptions,
  logger,
  priority
}: CreateMockMiddlewareOptions): Connect.NextHandleFunction;
//#endregion
//#region src/core/ws.d.ts
/**
* mock websocket
*/
declare function mockWebSocket(compiler: Compiler, server: Server | Http2SecureServer | null, {
  wsProxies: proxies,
  cookiesOptions,
  logger
}: ResolvedMockServerPluginOptions): void;
//#endregion
export { CreateMockMiddlewareOptions, Logger, createLogger, createMockMiddleware, logLevels, mockWebSocket, processMockData, processRawData, sortByValidator };